<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32-S3 Web Flasher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #444;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .section-title::before {
            content: '';
            display: inline-block;
            width: 4px;
            height: 20px;
            background: #667eea;
            margin-right: 10px;
            border-radius: 2px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
        }

        select, button {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        select {
            background: white;
            cursor: pointer;
        }

        select:hover {
            border-color: #667eea;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #connectBtn {
            background: #4CAF50;
        }

        #connectBtn:hover:not(:disabled) {
            background: #45a049;
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        #connectBtn.connected {
            background: #f44336;
        }

        #connectBtn.connected:hover {
            background: #da190b;
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
        }

        .console {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-top: 10px;
        }

        .console:empty::before {
            content: 'Console output will appear here...';
            color: #666;
        }

        .status {
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #2e7d32;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #c62828;
        }

        .status.warning {
            background: #fff3e0;
            color: #e65100;
            border-left: 4px solid #e65100;
        }

        .progress-container {
            width: 100%;
            height: 25px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 15px;
            display: none;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: 600;
        }

        .firmware-info {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .firmware-info strong {
            color: #333;
        }

        .variables-section {
            margin-top: 15px;
            padding: 15px;
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            border-radius: 6px;
        }

        .variables-section h3 {
            margin: 0 0 15px 0;
            font-size: 1em;
            color: #856404;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .variables-section h3 button {
            padding: 4px 10px;
            font-size: 0.85em;
            background: #fff;
            color: #856404;
            border: 1px solid #856404;
            border-radius: 4px;
            cursor: pointer;
            font-weight: normal;
        }

        .variables-section h3 button:hover {
            background: #fff8e1;
        }

        .variable-input-group {
            margin-bottom: 12px;
        }

        .variable-input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #555;
            font-weight: 500;
        }

        .variable-input-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .variable-input-wrapper input {
            flex: 1;
            padding: 8px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
        }

        .variable-input-wrapper input:focus {
            outline: none;
            border-color: #667eea;
        }

        .variable-input-wrapper .postfix,
        .variable-input-wrapper .prefix {
            color: #666;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            min-width: 200px;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #f8f9ff;
        }

        .btn-secondary:disabled {
            background: #f5f5f5;
            color: #999;
            border-color: #ddd;
            cursor: not-allowed;
        }

        @media (max-width: 600px) {
            .container {
                padding: 25px;
            }

            h1 {
                font-size: 1.5em;
            }

            .button-group button {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ ESP32-S3 Web Flasher</h1>
        <p class="subtitle">Flash your ESP32-S3 device directly from your browser</p>

        <div class="status" id="status"></div>

        <div class="section">
            <div class="section-title">1. Select Firmware</div>
            <label for="firmwareSelect">Choose firmware to flash:</label>
            <select id="firmwareSelect">
                <option value="amoled-t-display">Amoled T-Display - Factory Firmware</option>
                <option value="amoled-screencast">Amoled T-Display - Screencast</option>
            </select>
            <div class="firmware-info">
                <strong>Selected:</strong> Amoled T-Display Factory Firmware<br>
                <strong>Files:</strong> bootloader.bin, partitions.bin, boot_app0.bin, firmware.bin<br>
                <strong>Chip:</strong> ESP32-S3
            </div>
            <div id="variablesContainer"></div>
        </div>

        <div class="section">
            <div class="section-title">2. Connect Device</div>
            <button id="connectBtn">Connect to ESP32-S3</button>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                ‚ö†Ô∏è Make sure your device is in download mode and connected via USB
            </p>
        </div>

        <div class="section">
            <div class="section-title">3. Flash or Download Firmware</div>
            <div class="button-group">
                <button id="downloadBtn" class="btn-secondary" disabled>üì• Download Modified Firmware</button>
                <button id="flashBtn" disabled>‚ö° Flash Device</button>
            </div>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                üí° Tip: Download first to verify your configuration before flashing
            </p>
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar">0%</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Console Output</div>
            <div class="console" id="console"></div>
        </div>
    </div>

    <script type="module">
        import { Transport } from 'https://unpkg.com/esptool-js@0.4.1/bundle.js';
        import { ESPLoader } from 'https://unpkg.com/esptool-js@0.4.1/bundle.js';

        // Make them available globally for easier debugging
        window.Transport = Transport;
        window.ESPLoader = ESPLoader;

        // Constants
        const DISCONNECT_WAIT_MS = 1500;
        
        // Valid firmware paths (allowlist for security)
        const VALID_FIRMWARE_PATHS = [
            'Amoled-T-Display/Factory/Firmware/bootloader.bin',
            'Amoled-T-Display/Factory/Firmware/partitions.bin',
            'Amoled-T-Display/Factory/Firmware/boot_app0.bin',
            'Amoled-T-Display/Factory/Firmware/firmware.bin',
            'Amoled-T-Display/Screencast/Firmware/bootloader.bin',
            'Amoled-T-Display/Screencast/Firmware/partitions.bin',
            'Amoled-T-Display/Screencast/Firmware/boot_app0.bin',
            'Amoled-T-Display/Screencast/Firmware/firmware.bin'
        ];

        let esploader;
        let device;
        let transport;
        let chip = "ESP32-S3";
        let connected = false;

        const connectBtn = document.getElementById('connectBtn');
        const flashBtn = document.getElementById('flashBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const consoleDiv = document.getElementById('console');
        const statusDiv = document.getElementById('status');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const firmwareSelect = document.getElementById('firmwareSelect');
        const variablesContainer = document.getElementById('variablesContainer');

        // Load saved variables from localStorage
        const loadVariable = (key, defaultValue) => {
            const saved = localStorage.getItem(`fw_var_${key}`);
            return saved !== null ? saved : defaultValue;
        };

        // Save variable to localStorage
        const saveVariable = (key, value) => {
            localStorage.setItem(`fw_var_${key}`, value);
        };

        // Render variable inputs for selected firmware
        const renderVariables = (config) => {
            if (!config.variables || config.variables.length === 0) {
                variablesContainer.innerHTML = '';
                variablesContainer.style.display = 'none';
                return;
            }

            let html = '<div class="variables-section"><h3><span>‚öôÔ∏è Firmware Configuration</span><button id="resetVarsBtn">Reset to Defaults</button></h3>';
            
            config.variables.forEach((variable, index) => {
                const savedValue = loadVariable(variable.firmware_name, variable.default_value);
                const inputId = `var_input_${index}`;
                
                html += `<div class="variable-input-group">`;
                html += `<label for="${inputId}">${variable.readable_name}:</label>`;
                html += `<div class="variable-input-wrapper">`;
                
                if (variable.prefix) {
                    html += `<span class="prefix">${variable.prefix}</span>`;
                }
                
                html += `<input 
                    type="${variable.type || 'text'}" 
                    id="${inputId}" 
                    value="${savedValue}" 
                    maxlength="${variable.max_length || 100}"
                    data-firmware-name="${variable.firmware_name}"
                    data-max-length="${variable.max_length || 100}"
                />`;
                
                if (variable.postfix) {
                    html += `<span class="postfix">${variable.postfix}</span>`;
                }
                
                html += `</div></div>`;
            });
            
            html += '</div>';
            variablesContainer.innerHTML = html;
            variablesContainer.style.display = 'block';

            // Add event listeners to save values
            config.variables.forEach((variable, index) => {
                const input = document.getElementById(`var_input_${index}`);
                input.addEventListener('input', (e) => {
                    saveVariable(variable.firmware_name, e.target.value);
                });
            });

            // Add reset button handler
            const resetBtn = document.getElementById('resetVarsBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    config.variables.forEach((variable, index) => {
                        const input = document.getElementById(`var_input_${index}`);
                        input.value = variable.default_value;
                        saveVariable(variable.firmware_name, variable.default_value);
                    });
                    logToConsole('‚úì Variables reset to default values', 'success');
                    showStatus('Variables reset to defaults', 'success');
                    setTimeout(() => hideStatus(), 2000);
                });
            }
        };

        // Replace variables in firmware binary string
        const replaceVariablesInFirmware = async (binaryString, variables) => {
            let modifiedBinary = binaryString;
            const warnings = [];
            let wasModified = false;

            variables.forEach(variable => {
                const input = document.querySelector(`[data-firmware-name="${variable.firmware_name}"]`);
                if (!input) return;

                const value = input.value;
                const searchString = variable.firmware_name;
                const maxLen = variable.max_length || 100;
                
                // Find the search string in the binary
                const searchIndex = modifiedBinary.indexOf(searchString);
                if (searchIndex === -1) {
                    warnings.push(`Upload definition doesn't match firmware file. String '${searchString}' not found in the firmware.bin`);
                    return;
                }

                // Extract the entire padded region (searchString + padding to max_length)
                // In the firmware it looks like: const char ssid[100] = "|*S*|"; (followed by \0 to fill 100 bytes)
                const paddedRegionLength = maxLen;
                const originalPaddedRegion = modifiedBinary.substring(searchIndex, searchIndex + paddedRegionLength);
                
                // Create new replacement string with null terminator and padding
                let replacement = value;
                
                // Add null terminator
                replacement += '\0';
                
                // Pad with null bytes to max_length
                while (replacement.length < paddedRegionLength) {
                    replacement += '\0';
                }
                
                // Truncate if somehow too long (shouldn't happen with proper input validation)
                if (replacement.length > paddedRegionLength) {
                    replacement = replacement.substring(0, paddedRegionLength);
                    warnings.push(`Value for '${variable.readable_name}' was truncated to ${paddedRegionLength} bytes`);
                }

                // Only mark as modified if we're actually changing something
                if (replacement !== originalPaddedRegion) {
                    wasModified = true;
                    logToConsole(`Replacing '${searchString}' (${paddedRegionLength} bytes) with '${value}'`, 'info');
                }

                // Replace the entire padded region in binary
                modifiedBinary = modifiedBinary.substring(0, searchIndex) + 
                                 replacement + 
                                 modifiedBinary.substring(searchIndex + paddedRegionLength);
            });

            // Only recalculate checksum and SHA256 if we actually modified the firmware
            // This prevents corruption if no changes were made
            if (wasModified) {
                logToConsole('Variables were modified, recalculating firmware integrity...', 'info');
                modifiedBinary = await recalculateImageIntegrity(modifiedBinary);
            } else {
                logToConsole('No variables modified, keeping original firmware integrity', 'info');
            }

            return { modifiedBinary, warnings };
        };

        // Recalculate checksum and SHA256 digest for ESP32 firmware image
        const recalculateImageIntegrity = async (binaryString) => {
            // Check if image has extended header (byte 0 should be 0xE9)
            if (binaryString.charCodeAt(0) !== 0xE9) {
                logToConsole('Skipping integrity recalculation: not a valid ESP32 image', 'warning');
                return binaryString; // Not a valid ESP32 image
            }

            // Parse ESP32 image header
            const magic = binaryString.charCodeAt(0);
            const segmentCount = binaryString.charCodeAt(1);
            const flashMode = binaryString.charCodeAt(2);
            const flashSizeFreq = binaryString.charCodeAt(3);
            const entryPoint = binaryString.charCodeAt(4) | (binaryString.charCodeAt(5) << 8) | 
                               (binaryString.charCodeAt(6) << 16) | (binaryString.charCodeAt(7) << 24);
            
            logToConsole(`ESP32 Image: magic=0xE9, segments=${segmentCount}, entry=0x${entryPoint.toString(16)}`, 'info');

            // Parse extended header (byte 8+)
            const wpPin = binaryString.charCodeAt(8);
            const clkDrvSettings = [
                binaryString.charCodeAt(9), binaryString.charCodeAt(10),
                binaryString.charCodeAt(11), binaryString.charCodeAt(12)
            ];
            const chipId = binaryString.charCodeAt(13) | (binaryString.charCodeAt(14) << 8);
            const minChipRev = binaryString.charCodeAt(15);
            const reserved = [binaryString.charCodeAt(16), binaryString.charCodeAt(17)];
            const appendDigest = binaryString.charCodeAt(18);
            
            // Check if SHA256 is actually present
            // Use append_digest flag and size check (must be >= 33 bytes and multiple of 16)
            logToConsole(`Extended header: chip_id=${chipId}, append_digest=0x${appendDigest.toString(16).padStart(2, '0')}`, 'info');

            let originalLength = binaryString.length;
            logToConsole(`Original firmware size: ${originalLength} bytes`, 'info');

            // Detect SHA256 based on:
            // 1. Size is at least 33 bytes (1 checksum + 32 SHA256)
            // 2. Size is multiple of 16 (ESP32 requirement)
            // 3. append_digest flag is not 0x00 (usually 0x01 or 0xFF means present)
            // NOTE: We can't verify the hash because variables may have been replaced already
            const hasSHA256 = (originalLength >= 33 && originalLength % 16 === 0 && appendDigest !== 0x00);
            logToConsole(`SHA256 detection: ${hasSHA256 ? 'present' : 'not present'} (based on append_digest=${appendDigest}, size=${originalLength})`, 'info');

            // Remove SHA256 if present (32 bytes at end)
            let imageData;
            if (hasSHA256) {
                imageData = binaryString.substring(0, originalLength - 32);
                logToConsole(`Removed SHA256 (32 bytes). Image size: ${imageData.length} bytes`, 'info');
            } else {
                imageData = binaryString;
            }

            // The last byte before SHA256 is the checksum
            // Parse all segments to find where actual data ends
            let offset = 24; // After 8-byte main header + 16-byte extended header
            let segmentDataEnd = offset;
            
            logToConsole(`Parsing ${segmentCount} segments starting at offset ${offset}...`, 'info');
            
            for (let i = 0; i < segmentCount; i++) {
                if (offset + 8 > imageData.length) {
                    logToConsole(`ERROR: Segment ${i} header exceeds image bounds`, 'error');
                    break;
                }
                
                const segLoadAddr = binaryString.charCodeAt(offset) | (binaryString.charCodeAt(offset + 1) << 8) |
                                   (binaryString.charCodeAt(offset + 2) << 16) | (binaryString.charCodeAt(offset + 3) << 24);
                const segDataLen = binaryString.charCodeAt(offset + 4) | (binaryString.charCodeAt(offset + 5) << 8) |
                                  (binaryString.charCodeAt(offset + 6) << 16) | (binaryString.charCodeAt(offset + 7) << 24);
                
                logToConsole(`  Segment ${i}: addr=0x${segLoadAddr.toString(16)}, len=${segDataLen} bytes`, 'info');
                
                offset += 8; // Segment header
                offset += segDataLen; // Segment data
                segmentDataEnd = offset;
            }

            logToConsole(`All segments end at offset ${segmentDataEnd}`, 'info');

            // Now we have: [headers + segments] [padding] [checksum] [optional SHA256]
            // CRITICAL: The checksum is calculated ONLY over segment DATA bytes
            // NOT headers, NOT segment headers, NOT padding, NOT checksum itself
            // Algorithm: checksum = 0xEF XOR (all segment data bytes)
            
            const oldChecksum = imageData.charCodeAt(imageData.length - 1);
            
            // Calculate new checksum: XOR only segment DATA (excluding all headers and padding)
            let checksum = 0xEF;
            let segmentOffset = 24; // After 8-byte main header + 16-byte extended header
            let totalDataBytes = 0;
            
            for (let i = 0; i < segmentCount; i++) {
                // Read segment header (8 bytes)
                const segLoadAddr = binaryString.charCodeAt(segmentOffset) | (binaryString.charCodeAt(segmentOffset + 1) << 8) |
                                   (binaryString.charCodeAt(segmentOffset + 2) << 16) | (binaryString.charCodeAt(segmentOffset + 3) << 24);
                const segDataLen = binaryString.charCodeAt(segmentOffset + 4) | (binaryString.charCodeAt(segmentOffset + 5) << 8) |
                                  (binaryString.charCodeAt(segmentOffset + 6) << 16) | (binaryString.charCodeAt(segmentOffset + 7) << 24);
                
                segmentOffset += 8; // Skip segment header
                
                // XOR all DATA bytes in this segment
                for (let j = 0; j < segDataLen; j++) {
                    checksum ^= binaryString.charCodeAt(segmentOffset + j);
                }
                
                segmentOffset += segDataLen; // Move to next segment
                totalDataBytes += segDataLen;
            }
            
            logToConsole(`Checksum: old=0x${oldChecksum.toString(16).padStart(2, '0').toUpperCase()}, new=0x${checksum.toString(16).padStart(2, '0').toUpperCase()}`, 'info');
            logToConsole(`Checksum calculated over ${totalDataBytes} bytes (segment DATA only, excluding headers & padding)`, 'info');
            
            const dataBeforeChecksum = imageData.substring(0, imageData.length - 1);
            logToConsole(`DEBUG: imageData.length=${imageData.length}, dataBeforeChecksum.length=${dataBeforeChecksum.length}`, 'info');

            // Rebuild: [all data before checksum] [new checksum]
            let rebuiltImage = dataBeforeChecksum + String.fromCharCode(checksum);
            logToConsole(`DEBUG: rebuiltImage.length=${rebuiltImage.length}, checksum byte at -1 is 0x${rebuiltImage.charCodeAt(rebuiltImage.length - 1).toString(16)}`, 'info');
            
            // Verify size is still multiple of 16
            if (rebuiltImage.length % 16 !== 0) {
                logToConsole(`ERROR: Rebuilt image size ${rebuiltImage.length} is not multiple of 16!`, 'error');
            } else {
                logToConsole(`‚úì Image with new checksum: ${rebuiltImage.length} bytes (multiple of 16: OK)`, 'success');
            }

            // If SHA256 was present, recalculate it
            if (hasSHA256) {
                try {
                    // Convert binary string (including new checksum) to Uint8Array for SHA256 calculation
                    const dataArray = new Uint8Array(rebuiltImage.length);
                    for (let i = 0; i < rebuiltImage.length; i++) {
                        dataArray[i] = rebuiltImage.charCodeAt(i);
                    }

                    // Calculate SHA256 using Web Crypto API
                    const hashBuffer = await crypto.subtle.digest('SHA-256', dataArray);
                    const hashArray = new Uint8Array(hashBuffer);
                    
                    // Convert hash to binary string
                    let hashString = '';
                    for (let i = 0; i < hashArray.length; i++) {
                        hashString += String.fromCharCode(hashArray[i]);
                    }
                    
                    // Log first few bytes of SHA256 for debugging
                    const hashHex = Array.from(hashArray.slice(0, 8))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ');
                    logToConsole(`SHA256 (first 8 bytes): ${hashHex}...`, 'info');
                    
                    rebuiltImage += hashString;
                    logToConsole(`‚úì SHA256 digest recalculated. Final size: ${rebuiltImage.length} bytes`, 'success');
                } catch (error) {
                    logToConsole('ERROR: Could not recalculate SHA256: ' + error.message, 'error');
                    throw error; // Don't continue with corrupted firmware
                }
            } else {
                logToConsole('‚úì Checksum recalculated (no SHA256 in image)', 'success');
            }

            return rebuiltImage;
        };

        // Firmware configurations
        const firmwareConfigs = {
            'amoled-t-display': {
                name: 'Amoled T-Display Factory Firmware',
                files: [
                    //{ path: 'Amoled-T-Display/Factory/Firmware/bootloader.bin', offset: 0x0000},
                    { path: 'Amoled-T-Display/Factory/Firmware/partitions.bin', offset: 0x8000 },
                    { path: 'Amoled-T-Display/Factory/Firmware/boot_app0.bin', offset: 0xe000 },
                    { path: 'Amoled-T-Display/Factory/Firmware/firmware.bin', offset: 0x10000 }
                ]
            },
            'amoled-screencast': {
                name: 'Amoled T-Display Screencast',
                files: [
                    { path: 'Amoled-T-Display/Screencast/Firmware/bootloader.bin', offset: 0x0000 },
                    { path: 'Amoled-T-Display/Screencast/Firmware/partitions.bin', offset: 0x8000 },
                    { path: 'Amoled-T-Display/Screencast/Firmware/boot_app0.bin', offset: 0xe000 },
                    { path: 'Amoled-T-Display/Screencast/Firmware/firmware.bin', offset: 0x10000 }
                ],
                variables: [
                    {
                        firmware_name: '|*S*|',
                        readable_name: 'WiFi Name (SSID)',
                        default_value: 'ESP32-S3-T-Display',
                        max_length: 100,
                        type: 'text'
                    },
                    {
                        firmware_name: '|*P*|',
                        readable_name: 'WiFi Password',
                        default_value: 'testtest',
                        max_length: 100,
                        type: 'text'
                    },
                    {
                        firmware_name: '|*M*|',
                        readable_name: 'MDNS Hostname (*.local)',
                        default_value: 'esp32-s3-t-display',
                        postfix: '.local',
                        max_length: 100,
                        type: 'text'
                    },
                    {
                        firmware_name: 'WebRTC Stream',
                        readable_name: 'Display Name.',
                        default_value: 'WebRTC Stream',
                        max_length: 13,
                        type: 'text'
                    }
                ]
            }
        };

        function logToConsole(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            consoleDiv.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        function hideStatus() {
            statusDiv.style.display = 'none';
        }

        function updateProgress(percentage) {
            progressBar.style.width = percentage + '%';
            progressBar.textContent = Math.round(percentage) + '%';
        }

        const formatMacAddr = (macAddr) => {
            return macAddr.map((value) => value.toString(16).toUpperCase().padStart(2, '0')).join(':');
        };

        const sleep = (ms) => {
            return new Promise((resolve) => setTimeout(resolve, ms));
        };

        connectBtn.addEventListener('click', async () => {
            if (connected) {
                // Disconnect
                try {
                    await disconnect();
                    logToConsole('Disconnected from device', 'success');
                    showStatus('Disconnected successfully', 'info');
                } catch (error) {
                    logToConsole('Error during disconnect: ' + error.message, 'error');
                    showStatus('Error disconnecting: ' + error.message, 'error');
                }
            } else {
                // Connect
                try {
                    // Check if esptool-js is loaded
                    if (typeof Transport === 'undefined' || typeof ESPLoader === 'undefined') {
                        throw new Error('esptool-js library failed to load. Please refresh the page.');
                    }

                    logToConsole('Requesting USB device access...', 'info');
                    device = await navigator.serial.requestPort({});
                    
                    logToConsole('Creating transport...', 'info');
                    transport = new Transport(device, true);
                    
                    logToConsole('Connecting to ESP32-S3...', 'info');
                    esploader = new ESPLoader({
                        transport: transport,
                        baudrate: 115200,
                        terminal: {
                            clean: () => {},
                            writeLine: (data) => logToConsole(data),
                            write: (data) => logToConsole(data)
                        }
                    });
                    
                    await esploader.main();
                    logToConsole('Connected successfully!', 'success');
                    
                    const chipName = await esploader.chip.CHIP_NAME;
                    logToConsole('Chip: ' + chipName, 'success');
                    
                    const macAddr = await esploader.chip.MAC_EFUSE_REG;
                    logToConsole('MAC Address: ' + macAddr, 'info');
                    
                    connected = true;
                    connectBtn.textContent = 'Disconnect';
                    connectBtn.classList.add('connected');
                    flashBtn.disabled = false;
                    
                    showStatus('Connected to ' + chipName + ' - Ready to flash!', 'success');
                } catch (error) {
                    logToConsole('Connection failed: ' + error.message, 'error');
                    showStatus('Connection failed: ' + error.message, 'error');
                    await disconnect();
                }
            }
        });

        // Function to load and prepare modified firmware for download
        const prepareModifiedFirmware = async () => {
            const selectedFirmware = firmwareSelect.value;
            const config = firmwareConfigs[selectedFirmware];

            // Find the firmware.bin file
            const firmwareFile = config.files.find(f => f.path.endsWith('firmware.bin'));
            if (!firmwareFile) {
                throw new Error('firmware.bin not found in configuration');
            }

            // Validate file path
            if (!VALID_FIRMWARE_PATHS.includes(firmwareFile.path)) {
                throw new Error(`Invalid firmware path: ${firmwareFile.path}`);
            }

            // Load firmware.bin
            logToConsole(`Loading ${firmwareFile.path}...`, 'info');
            const response = await fetch(firmwareFile.path);
            if (!response.ok) {
                throw new Error(`Failed to load ${firmwareFile.path}: ${response.statusText}`);
            }
            const data = await response.arrayBuffer();

            // Convert to binary string
            const bytes = new Uint8Array(data);
            let binaryString = '';
            for (let i = 0; i < bytes.length; i++) {
                binaryString += String.fromCharCode(bytes[i]);
            }

            // Replace variables if configured
            if (config.variables && config.variables.length > 0) {
                logToConsole('Replacing variables in firmware...', 'info');
                const { modifiedBinary, warnings } = await replaceVariablesInFirmware(
                    binaryString,
                    config.variables
                );

                warnings.forEach(warning => {
                    logToConsole(warning, 'warning');
                });

                return modifiedBinary;
            }

            return binaryString;
        };

        // Download button handler
        downloadBtn.addEventListener('click', async () => {
            try {
                downloadBtn.disabled = true;
                logToConsole('Preparing firmware for download...', 'info');
                showStatus('Preparing firmware...', 'info');

                const modifiedFirmware = await prepareModifiedFirmware();

                // Convert binary string to Blob
                const bytes = new Uint8Array(modifiedFirmware.length);
                for (let i = 0; i < modifiedFirmware.length; i++) {
                    bytes[i] = modifiedFirmware.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'application/octet-stream' });

                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'firmware_modified.bin';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                logToConsole(`‚úì Firmware downloaded: firmware_modified.bin (${bytes.length} bytes)`, 'success');
                showStatus('Firmware downloaded successfully!', 'success');
            } catch (error) {
                logToConsole('ERROR: Failed to prepare firmware: ' + error.message, 'error');
                showStatus('Failed to prepare firmware: ' + error.message, 'error');
            } finally {
                downloadBtn.disabled = false;
            }
        });

        flashBtn.addEventListener('click', async () => {
            if (!connected) {
                showStatus('Please connect to device first', 'warning');
                return;
            }

            try {
                flashBtn.disabled = true;
                connectBtn.disabled = true;
                firmwareSelect.disabled = true;
                progressContainer.style.display = 'block';
                updateProgress(0);

                const selectedFirmware = firmwareSelect.value;
                const config = firmwareConfigs[selectedFirmware];
                
                logToConsole('Starting flash process for: ' + config.name, 'info');
                showStatus('Flashing firmware...', 'info');

                // Load all firmware files
                const fileArray = [];
                let firmwareBinData = null; // Store firmware.bin for variable replacement
                
                for (let i = 0; i < config.files.length; i++) {
                    const file = config.files[i];
                    
                    // Validate file path against allowlist
                    if (!VALID_FIRMWARE_PATHS.includes(file.path)) {
                        throw new Error(`Invalid firmware path: ${file.path}`);
                    }
                    
                    logToConsole(`Loading ${file.path}...`, 'info');
                    
                    try {
                        const response = await fetch(file.path);
                        if (!response.ok) {
                            throw new Error(`Failed to load ${file.path}: ${response.statusText}`);
                        }
                        const data = await response.arrayBuffer();
                        
                        // Convert ArrayBuffer to binary string (required by esp-web-flasher)
                        const bytes = new Uint8Array(data);
                        let binaryString = '';
                        for (let i = 0; i < bytes.length; i++) {
                            binaryString += String.fromCharCode(bytes[i]);
                        }
                        
                        // Check if this is firmware.bin and has variables
                        const isFirmwareBin = file.path.endsWith('firmware.bin');
                        if (isFirmwareBin && config.variables && config.variables.length > 0) {
                            firmwareBinData = { binaryString, offset: file.offset, path: file.path };
                        } else {
                            fileArray.push({
                                data: binaryString,
                                address: file.offset
                            });
                        }
                        
                        const progress = ((i + 1) / config.files.length) * 20;
                        updateProgress(progress);
                        logToConsole(`‚úì Loaded ${file.path} (${data.byteLength} bytes)`, 'success');
                    } catch (error) {
                        throw new Error(`Failed to load ${file.path}: ${error.message}`);
                    }
                }

                // Process firmware.bin with variables if needed
                if (firmwareBinData && config.variables) {
                    logToConsole('Processing firmware variables...', 'info');
                    const { modifiedBinary, warnings } = await replaceVariablesInFirmware(
                        firmwareBinData.binaryString,
                        config.variables
                    );
                    
                    // Show warnings if any
                    warnings.forEach(warning => {
                        logToConsole(warning, 'warning');
                    });
                    
                    fileArray.push({
                        data: modifiedBinary,
                        address: firmwareBinData.offset
                    });
                    
                    logToConsole('‚úì Variables processed', 'success');
                } else if (firmwareBinData) {
                    // No variables, add firmware.bin as-is
                    fileArray.push({
                        data: firmwareBinData.binaryString,
                        address: firmwareBinData.offset
                    });
                }

                logToConsole('All files loaded, starting flash...', 'info');
                updateProgress(20);

                // Flash the files with proper configuration
                const flashOptions = {
                    fileArray: fileArray,
                    flashSize: "keep",
                    eraseAll: false,
                    compress: true,
                    reportProgress: (fileIndex, written, total) => {
                        const baseProgress = 20 + ((fileIndex / fileArray.length) * 70) + ((written / total) * (70 / fileArray.length));
                        updateProgress(baseProgress);
                    },
                    calculateMD5Hash: (image) => {
                        // Simple MD5 calculation - you can use CryptoJS if needed
                        return undefined; // Skip MD5 for now
                    }
                };

                await esploader.writeFlash(flashOptions);
                
                updateProgress(90);
                logToConsole('Flash completed successfully! ‚ú®', 'success');
                logToConsole('Performing hard reset...', 'info');
                
                // Hard reset the device after flashing (like --after hard_reset)
                await esploader.hardReset();
                await sleep(DISCONNECT_WAIT_MS);
                
                updateProgress(100);
                logToConsole('Device reset complete!', 'success');
                showStatus('Flash completed successfully! Device has been reset and should boot now.', 'success');

            } catch (error) {
                logToConsole('Flash failed: ' + error.message, 'error');
                console.error(error);
                showStatus('Flash failed: ' + error.message, 'error');
                updateProgress(0);
            } finally {
                flashBtn.disabled = false;
                connectBtn.disabled = false;
                firmwareSelect.disabled = false;
            }
        });

        async function disconnect() {
            if (esploader) {
                try {
                    await esploader.disconnect();
                    await sleep(DISCONNECT_WAIT_MS);
                } catch (error) {
                    console.log('Disconnect error:', error.message);
                }
            }
            
            connected = false;
            connectBtn.textContent = 'Connect to ESP32-S3';
            connectBtn.classList.remove('connected');
            flashBtn.disabled = true;
            esploader = null;
        }

        // Check for Web Serial API support
        window.addEventListener('load', () => {
            if (!('serial' in navigator)) {
                showStatus('Web Serial API is not supported in this browser. Please use Chrome, Edge, or Opera.', 'error');
                connectBtn.disabled = true;
                logToConsole('Web Serial API not supported', 'error');
            } else {
                logToConsole('Web Serial API supported - Ready to connect!', 'success');
            }
        });

        // Update firmware info when selection changes
        firmwareSelect.addEventListener('change', (e) => {
            const config = firmwareConfigs[e.target.value];
            const infoDiv = document.querySelector('.firmware-info');
            infoDiv.innerHTML = `
                <strong>Selected:</strong> ${config.name}<br>
                <strong>Files:</strong> ${config.files.map(f => f.path.split('/').pop()).join(', ')}<br>
                <strong>Chip:</strong> ESP32-S3
            `;
            
            // Render variable inputs if present
            renderVariables(config);
            
            // Enable download button if firmware has variables (can be downloaded without connection)
            downloadBtn.disabled = !config.variables || config.variables.length === 0;
        });

        // Initialize with default firmware variables
        window.addEventListener('load', () => {
            const defaultConfig = firmwareConfigs[firmwareSelect.value];
            renderVariables(defaultConfig);
            
            // Enable download button if default firmware has variables
            downloadBtn.disabled = !defaultConfig.variables || defaultConfig.variables.length === 0;
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Video Stream Client</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            color: #4CAF50;
            margin-bottom: 10px;
        }
        video {
            max-width: 100%;
            width: 640px;
            border: 3px solid #333;
            border-radius: 10px;
            margin: 20px 0;
            background: #000;
        }
        button {
            padding: 15px 40px;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(76, 175, 80, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: bold;
            font-size: 16px;
        }
        .success { background: #4CAF50; }
        .error { background: #f44336; }
        .info { background: #2196F3; }
        .warning { background: #ff9800; }
        .stats {
            background: rgba(33, 33, 33, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }
        .stats div {
            margin: 5px 0;
        }
        .config {
            background: rgba(33, 33, 33, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: left;
        }
        .config label {
            display: inline-block;
            width: 150px;
            margin: 10px 0;
        }
        .config input {
            width: 200px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: #222;
            color: white;
        }
        .quality-slider {
            width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• ESP32 AMOLED Video Stream</h1>
        <p>Stream your webcam to ESP32 display via WiFi</p>
        
        <div class="config">
            <h3>‚öôÔ∏è Configuration</h3>
            <div>
                <label>ESP32 Address:</label>
                <input type="text" id="espAddress" value="http://esp.local" placeholder="http://esp.local">
            </div>
            <div>
                <label>Display Size:</label>
                <select id="displaySize" style="width: 200px; padding: 8px; border-radius: 5px; border: 1px solid #555; background: #222; color: white;">
                    <option value="536x240" selected>536x240 (1.91" AMOLED)</option>
                    <option value="450x600">450x600 (2.41" AMOLED)</option>
                    <option value="194x368">194x368 (1.47" AMOLED)</option>
                    <option value="custom">Custom...</option>
                </select>
            </div>
            <div id="customSizeDiv" style="display: none;">
                <label>Custom Size:</label>
                <input type="number" id="customWidth" placeholder="Width" style="width: 90px; padding: 8px; border-radius: 5px; border: 1px solid #555; background: #222; color: white;">
                x
                <input type="number" id="customHeight" placeholder="Height" style="width: 90px; padding: 8px; border-radius: 5px; border: 1px solid #555; background: #222; color: white;">
            </div>
            <div>
                <label>Source:</label>
                <select id="sourceType" style="width: 200px; padding: 8px; border-radius: 5px; border: 1px solid #555; background: #222; color: white;">
                    <option value="camera">üìπ Webcam</option>
                    <option value="screen">üñ•Ô∏è Screen Share</option>
                </select>
            </div>
            <div>
                <label>Frame Rate (FPS):</label>
                <input type="number" id="frameRate" value="6" min="1" max="30">
            </div>
            <div>
                <label>JPEG Quality:</label>
                <input type="range" id="quality" class="quality-slider" value="0.7" min="0.1" max="1.0" step="0.1">
                <span id="qualityValue">0.7</span>
            </div>
            <div>
                <label>
                    <input type="checkbox" id="monoMode" style="margin-right: 8px;">
                    üé® Monochrome Mode (faster, smaller files)
                </label>
            </div>
        </div>

        <video id="video" autoplay playsinline></video>
        <canvas id="canvas" style="display:none;"></canvas>
        
        <div>
            <button id="startBtn" onclick="startStreaming()">‚ñ∂Ô∏è Start Streaming</button>
            <button id="stopBtn" onclick="stopStreaming()" disabled>‚èπÔ∏è Stop Streaming</button>
        </div>
        
        <div id="status" class="status info">üì° Ready to stream</div>
        
        <div class="stats">
            <h3>üìä Statistics</h3>
            <div id="stats">
                <div>Frames Sent: <span id="frameCount">0</span></div>
                <div>Errors: <span id="errorCount">0</span></div>
                <div>Data Sent: <span id="dataSize">0 KB</span></div>
                <div>Actual FPS: <span id="actualFPS">0</span></div>
                <div>Avg Frame Size: <span id="avgFrameSize">0 KB</span></div>
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 12px; color: #888;">
            <p>üí° Tips:</p>
            <ul style="text-align: left; display: inline-block;">
                <li>Make sure your ESP32 is connected to WiFi</li>
                <li>ESP32 should be accessible at <code>esp.local</code></li>
                <li>Select the correct display size for your AMOLED screen</li>
                <li>Video is automatically scaled to match display dimensions</li>
                <li>Choose between webcam or screen capture</li>
                <li>Screen share works in Chrome, Edge, and Firefox</li>
                <li>Lower frame rate or quality if stream is laggy</li>
                <li>Grant camera/screen permissions when prompted</li>
            </ul>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const espAddressInput = document.getElementById('espAddress');
        const frameRateInput = document.getElementById('frameRate');
        const qualitySlider = document.getElementById('quality');
        const qualityValue = document.getElementById('qualityValue');
        const sourceTypeSelect = document.getElementById('sourceType');
        const displaySizeSelect = document.getElementById('displaySize');
        const customSizeDiv = document.getElementById('customSizeDiv');
        const customWidthInput = document.getElementById('customWidth');
        const customHeightInput = document.getElementById('customHeight');
        const monoModeCheckbox = document.getElementById('monoMode');
        
        let streaming = false;
        let frameCount = 0;
        let errorCount = 0;
        let totalDataSize = 0;
        let lastFrameTime = 0;
        let fpsHistory = [];
        let frameSizeHistory = [];
        
        // WebSocket connection
        let ws = null;
        let wsConnected = false;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectDelay = 2000; // Start with 2 seconds
        let reconnectTimer = null;

        // Update quality value display
        qualitySlider.addEventListener('input', (e) => {
            qualityValue.textContent = e.target.value;
        });

        // Handle display size selection
        displaySizeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'custom') {
                customSizeDiv.style.display = 'block';
            } else {
                customSizeDiv.style.display = 'none';
            }
        });

        // Function to get current display dimensions
        function getDisplayDimensions() {
            const sizeValue = displaySizeSelect.value;
            if (sizeValue === 'custom') {
                const w = parseInt(customWidthInput.value) || 536;
                const h = parseInt(customHeightInput.value) || 240;
                return { width: w, height: h };
            } else {
                const [width, height] = sizeValue.split('x').map(Number);
                return { width, height };
            }
        }

        function updateStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

        function updateStats(frameSize) {
            document.getElementById('frameCount').textContent = frameCount;
            document.getElementById('errorCount').textContent = errorCount;
            document.getElementById('dataSize').textContent = (totalDataSize / 1024).toFixed(2);
            
            // Calculate FPS
            const now = Date.now();
            if (lastFrameTime > 0) {
                const fps = 1000 / (now - lastFrameTime);
                fpsHistory.push(fps);
                if (fpsHistory.length > 10) fpsHistory.shift();
                const avgFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
                document.getElementById('actualFPS').textContent = avgFps.toFixed(1);
            }
            lastFrameTime = now;

            // Track frame sizes
            if (frameSize) {
                frameSizeHistory.push(frameSize);
                if (frameSizeHistory.length > 10) frameSizeHistory.shift();
                const avgSize = frameSizeHistory.reduce((a, b) => a + b, 0) / frameSizeHistory.length;
                document.getElementById('avgFrameSize').textContent = (avgSize / 1024).toFixed(2);
            }
        }

        function connectWebSocket() {
            return new Promise((resolve, reject) => {
                const espAddress = espAddressInput.value.trim();
                const isMono = monoModeCheckbox.checked;
                const wsEndpoint = isMono ? '/ws-mono' : '/ws';
                const wsUrl = espAddress.replace('http://', 'ws://').replace('https://', 'wss://') + wsEndpoint;
                
                updateStatus(`üîå Connecting to ${isMono ? 'monochrome' : 'color'} WebSocket...`, 'info');
                
                ws = new WebSocket(wsUrl);
                ws.binaryType = 'arraybuffer';
                
                ws.onopen = () => {
                    wsConnected = true;
                    reconnectAttempts = 0; // Reset reconnect counter on successful connection
                    reconnectDelay = 2000; // Reset delay
                    console.log('WebSocket connected!');
                    resolve();
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    wsConnected = false;
                    reject(error);
                };
                
                ws.onclose = () => {
                    console.log('WebSocket closed');
                    const wasConnected = wsConnected;
                    wsConnected = false;
                    
                    if (streaming && wasConnected) {
                        // Connection was lost while streaming - attempt to reconnect
                        updateStatus('‚ö†Ô∏è Connection lost - attempting to reconnect...', 'warning');
                        attemptReconnect();
                    }
                };
            });
        }

        function attemptReconnect() {
            if (!streaming) {
                // User stopped streaming, don't reconnect
                return;
            }
            
            if (reconnectAttempts >= maxReconnectAttempts) {
                updateStatus('‚ùå Max reconnection attempts reached', 'error');
                stopStreaming();
                return;
            }
            
            reconnectAttempts++;
            updateStatus(`üîÑ Reconnecting (attempt ${reconnectAttempts}/${maxReconnectAttempts})...`, 'warning');
            
            // Clear any existing timer
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
            }
            
            // Exponential backoff: double the delay each time, max 30 seconds
            const currentDelay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), 30000);
            
            reconnectTimer = setTimeout(async () => {
                try {
                    await connectWebSocket();
                    updateStatus('‚úÖ Reconnected successfully!', 'success');
                } catch (err) {
                    console.error('Reconnection failed:', err);
                    // Will trigger onclose which will call attemptReconnect again
                }
            }, currentDelay);
        }

        async function startStreaming() {
            try {
                // Connect WebSocket first
                await connectWebSocket();
                
                // Now request media stream
                const sourceType = sourceTypeSelect.value;
                let stream;
                
                if (sourceType === 'screen') {
                    // Request screen capture
                    updateStatus('üñ•Ô∏è Requesting screen share...', 'info');
                    stream = await navigator.mediaDevices.getDisplayMedia({ 
                        video: { 
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    });
                } else {
                    // Request camera access
                    updateStatus('üé• Requesting camera access...', 'info');
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        } 
                    });
                }
                
                video.srcObject = stream;
                streaming = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                frameCount = 0;
                errorCount = 0;
                totalDataSize = 0;
                fpsHistory = [];
                frameSizeHistory = [];
                
                updateStatus('‚úÖ Streaming active', 'success');
                
                // Wait for video to be ready
                video.onloadedmetadata = () => {
                    sendFrames();
                };
                
                // Handle stream ending (user stops screen share)
                stream.getVideoTracks()[0].addEventListener('ended', () => {
                    console.log('Stream ended by user');
                    stopStreaming();
                });
                
            } catch (err) {
                console.error('Error starting stream:', err);
                
                if (err.name === 'NotAllowedError') {
                    updateStatus('‚ùå Permission denied', 'error');
                } else if (err.name === 'NotFoundError') {
                    updateStatus('‚ùå Source not found', 'error');
                } else if (err.name === 'NotSupportedError') {
                    updateStatus('‚ùå Screen capture not supported', 'error');
                } else {
                    updateStatus('‚ùå Error: ' + err.message, 'error');
                }
                
                // Clean up on error
                if (ws && wsConnected) {
                    ws.close();
                    ws = null;
                }
                streaming = false;
            }
        }

        function stopStreaming() {
            streaming = false;
            
            // Clear reconnection timer
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            reconnectAttempts = 0;
            
            // Stop media stream
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            // Close WebSocket
            if (ws && wsConnected) {
                ws.close();
                ws = null;
                wsConnected = false;
            }
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            updateStatus('‚èπÔ∏è Streaming stopped', 'info');
        }

        async function sendFrames() {
            if (!streaming || !wsConnected || !ws) return;

            // Get display dimensions from settings
            const displayDims = getDisplayDimensions();
            const isMono = monoModeCheckbox.checked;
            
            // Set canvas size to match ESP32 display
            if (video.videoWidth && video.videoHeight) {
                canvas.width = displayDims.width;
                canvas.height = displayDims.height;

                // Draw current video frame to canvas (scaled to display size)
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Convert to grayscale if monochrome mode
                if (isMono) {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Convert to grayscale using luminance formula
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                        data[i] = gray;     // R
                        data[i + 1] = gray; // G
                        data[i + 2] = gray; // B
                        // Alpha stays the same
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                }

                // Convert to JPEG blob
                const quality = parseFloat(qualitySlider.value);
                
                console.log(`Sending frame: ${canvas.width}x${canvas.height}, quality: ${quality}`);
                
                canvas.toBlob(async (blob) => {
                    if (blob && streaming && wsConnected) {
                        try {
                            // Send via WebSocket - MUCH faster than HTTP POST!
                            const arrayBuffer = await blob.arrayBuffer();
                            
                            if (ws.readyState === WebSocket.OPEN) {
                                ws.send(arrayBuffer);
                                
                                console.log(`Sent ${arrayBuffer.byteLength} bytes via WebSocket`);
                                
                                frameCount++;
                                totalDataSize += arrayBuffer.byteLength;
                                updateStats(arrayBuffer.byteLength);
                            }
                            
                        } catch (err) {
                            errorCount++;
                            updateStats();
                            console.error('WebSocket send error:', err);
                            updateStatus('‚ö†Ô∏è Connection issue', 'warning');
                        }
                    }
                    
                    // Schedule next frame based on desired frame rate
                    if (streaming) {
                        const fps = parseInt(frameRateInput.value) || 6;
                        const delay = 1000 / fps;
                        setTimeout(sendFrames, delay);
                    }
                }, 'image/jpeg', quality);
            } else {
                // Video not ready, try again
                if (streaming) {
                    setTimeout(sendFrames, 100);
                }
            }
        }

        // Parse URL query parameters and populate form fields
        function loadQueryParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // ESP32 Address
            if (urlParams.has('espAddress')) {
                espAddressInput.value = urlParams.get('espAddress');
            }
            
            // Display Size
            if (urlParams.has('displaySize')) {
                const size = urlParams.get('displaySize');
                // Check if it's a predefined size or custom
                const validSizes = ['536x240', '450x600', '194x368'];
                if (validSizes.includes(size)) {
                    displaySizeSelect.value = size;
                } else if (size === 'custom' || size.includes('x')) {
                    displaySizeSelect.value = 'custom';
                    customSizeDiv.style.display = 'block';
                    
                    // Parse custom dimensions if provided in WxH format
                    if (size !== 'custom' && size.includes('x')) {
                        const [w, h] = size.split('x').map(Number);
                        if (!isNaN(w) && !isNaN(h)) {
                            customWidthInput.value = w;
                            customHeightInput.value = h;
                        }
                    }
                }
            }
            
            // Custom Width
            if (urlParams.has('customWidth')) {
                const w = parseInt(urlParams.get('customWidth'));
                if (!isNaN(w)) {
                    customWidthInput.value = w;
                    if (displaySizeSelect.value !== 'custom') {
                        displaySizeSelect.value = 'custom';
                        customSizeDiv.style.display = 'block';
                    }
                }
            }
            
            // Custom Height
            if (urlParams.has('customHeight')) {
                const h = parseInt(urlParams.get('customHeight'));
                if (!isNaN(h)) {
                    customHeightInput.value = h;
                    if (displaySizeSelect.value !== 'custom') {
                        displaySizeSelect.value = 'custom';
                        customSizeDiv.style.display = 'block';
                    }
                }
            }
            
            // Source Type
            if (urlParams.has('sourceType')) {
                const source = urlParams.get('sourceType');
                if (source === 'camera' || source === 'screen') {
                    sourceTypeSelect.value = source;
                }
            }
            
            // Frame Rate
            if (urlParams.has('frameRate')) {
                const fps = parseInt(urlParams.get('frameRate'));
                if (!isNaN(fps) && fps >= 1 && fps <= 30) {
                    frameRateInput.value = fps;
                }
            }
            
            // JPEG Quality
            if (urlParams.has('quality')) {
                const q = parseFloat(urlParams.get('quality'));
                if (!isNaN(q) && q >= 0.1 && q <= 1.0) {
                    qualitySlider.value = q;
                    qualityValue.textContent = q;
                }
            }
            
            // Monochrome Mode
            if (urlParams.has('monoMode')) {
                const mono = urlParams.get('monoMode');
                monoModeCheckbox.checked = (mono === 'true' || mono === '1' || mono === 'yes');
            }
        }

        // Auto-detect ESP32 if on local network
        window.addEventListener('load', () => {
            loadQueryParameters();
            console.log('Ready to stream to ESP32');
        });
    </script>
</body>
</html>
